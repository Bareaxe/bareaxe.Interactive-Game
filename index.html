<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Side Scroller Choice Game</title>
<style>
body {
  margin: 0;
  background: #111;
  overflow: hidden;
  font-family: monospace;
}

canvas {
  display: block;
  margin: auto;
  background: linear-gradient(#6bd6ff, #dff6ff);
}
</style>
</head>

<body>
<canvas id="game" width="900" height="450"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const gravity = 0.7;
let gameState = "play";

const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

/* ---------------- PLAYER ---------------- */

const player = {
  x: 100,
  y: 300,
  w: 40,
  h: 50,
  vx: 0,
  vy: 0,
  onGround: false,
  frame: 0,
  animTimer: 0
};

/* ---------------- WORLD ---------------- */

const ground = {
  y: 380
};

const doors = [
  {x: 700, y: 320, good:false},
  {x: 900, y: 320, good:false},
  {x: 1100, y: 320, good:true}, // REAL ENDING
  {x: 1300, y: 320, good:false}
];

let cameraX = 0;

/* ---------------- UPDATE ---------------- */

function update() {
  if(gameState !== "play") return;

  // Movement
  if(keys["a"]) player.vx = -4;
  else if(keys["d"]) player.vx = 4;
  else player.vx *= 0.8;

  if((keys["w"] || keys[" "]) && player.onGround){
    player.vy = -12;
    player.onGround = false;
  }

  // Gravity
  player.vy += gravity;

  player.x += player.vx;
  player.y += player.vy;

  // Ground collision
  if(player.y + player.h >= ground.y){
    player.y = ground.y - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  // Camera follow
  cameraX = player.x - 200;

  // Animate
  player.animTimer++;
  if(player.animTimer > 8){
    player.frame = (player.frame + 1) % 4;
    player.animTimer = 0;
  }

  // Door collisions
  doors.forEach(d => {
    if(
      player.x < d.x + 50 &&
      player.x + player.w > d.x &&
      player.y < d.y + 60 &&
      player.y + player.h > d.y
    ){
      gameState = d.good ? "win" : "lose";
    }
  });
}

/* ---------------- DRAW ---------------- */

function drawPlayer(){
  // Simple sprite animation using colors
  const colors = ["#ff4444","#ff7777","#ffaaaa","#ff7777"];
  ctx.fillStyle = colors[player.frame];
  ctx.fillRect(player.x - cameraX, player.y, player.w, player.h);

  // Eyes
  ctx.fillStyle = "#000";
  ctx.fillRect(player.x - cameraX + 10, player.y + 15, 5, 5);
  ctx.fillRect(player.x - cameraX + 25, player.y + 15, 5, 5);
}

function drawWorld(){
  // Ground
  ctx.fillStyle = "#4caf50";
  ctx.fillRect(0, ground.y, canvas.width, canvas.height-ground.y);

  // Doors
  doors.forEach((d,i)=>{
    ctx.fillStyle = "#654321";
    ctx.fillRect(d.x - cameraX, d.y, 50, 60);

    ctx.fillStyle = "#ffd700";
    ctx.fillRect(d.x - cameraX + 35, d.y + 30, 8, 8);

    ctx.fillStyle = "#fff";
    ctx.fillText("Door " + (i+1), d.x - cameraX, d.y-10);
  });
}

function drawUI(){
  if(gameState==="win"){
    drawOverlay("YOU FOUND THE TRUE ENDING!");
  }
  if(gameState==="lose"){
    drawOverlay("BAD ENDING...\nRefresh to try again.");
  }
}

function drawOverlay(text){
  ctx.fillStyle="rgba(0,0,0,0.7)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#fff";
  ctx.font="36px monospace";
  ctx.textAlign="center";
  ctx.fillText(text, canvas.width/2, canvas.height/2);
}

/* ---------------- LOOP ---------------- */

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  update();
  drawWorld();
  drawPlayer();
  drawUI();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
